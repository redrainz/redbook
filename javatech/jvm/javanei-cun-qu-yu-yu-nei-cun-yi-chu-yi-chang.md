Java内存区域与内存溢出异常
==============================
内存溢出 out of memory，是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；比如申请了一个integer,但给它存了long才能存下的数，那就是内存溢出。分配的内存不足以放下数据项序列,称为内存溢出

内存泄露 memory                         leak，是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。

![jvm内存模型](/assets/82a67231c3e64ed3904390e4c55150a1.jpg)
1.  运行时数据区域

    * 程序计数器（Program Counter Register）
        - 线程隔离（私有）的数据区

        - 每个线程有一个，线程独立各不影响

        - 当前线程所执行的行号指示器

        - 如果线程正在执行的是一个**Java方法**，这个计数器记录的是正在执行的**虚拟机字节码指令的地址**

        - 如果执行的是**native**方法，这个计数器值为空（Undefined）

    * Java虚拟机栈（VM Stack）
        - 线程隔离（私有）的数据区

        - 每个线程有一个，线程独立各不影响

        - Jvm栈描述的是Java方法执行的内存模型

        - 每个方法执行时会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用至执行完成的过程，就是一个栈帧在栈中入栈出栈的过程。

        - 局部变量表存放了编译期可知的**各种基本数据类型**(boolean、byte、char、short、int、long、float、double)、
        **对象引用**（reference类型，它不等同于变量本身，它可能是一个指向对象起始位置的引用指针，也可能是指向代表对象的句柄或其他与此对象相关的位置）、**returnAddress类型**（指向一条字节码指令的地址）

        - 64位的**long、double**占用**2**个局部变量空间（Slot），其余的数据类型占用1个

        - **局部变量表的内存空间在编译期间完成分配，方法运行期间局部变量表空间大小确定不会改变**
        
        - 线程请求的栈深度大于虚拟机所允许的深度，将会抛出**StackOverflowError**异常
        
        - VM栈可以固定长度也可以动态扩展，如果扩展时申请不到足够的内存，将会抛出**OutOfMemoryError**异常

    * 本地方法栈

        - 线程隔离（私有）的数据区

        - 每个线程有一个，线程独立各不影响

        - 与VM栈相似，区别不过是VM栈为VM执行**Java方法（也就是字节码）服务**，而本地方法栈则为VM执行使用到的**Native方法服务**。

        - VM规范对它的语言、使用方式和数据结构不做规范，VM可以自由实现它

        - 本地方法栈区域也会抛出**StackOverflowError**异常和**OutOfMemoryError**异常

    * Java堆（Java Heap）

        - **所有线程共享的区域，在VM启动时创建**
        
        - 对大多数应用来说是VM管理的内存中最大的一块

        - 用于**存放对象实例和数组**

        - VM规范要求所有的**对象实例和数组都要在堆上分配**，但由于**栈上分配、标量替换**优化技术会导致一些微妙的变化，所有的对象都分配在堆上并不是那么绝对了

        - Java堆是垃圾收集器管理的主要区域，经常被称为“GC堆”

        - 从内存回收的角度，现在的收集器都使用**分代收集算法**，所以可以细分为**新生代**和**老年代**，继续可细分为**Eden空间、From Survivor空间、To Survivor空间**等

        - 从内存分配的角度，线程共享的Java堆可能划分为多个**线程私有的分配缓冲区**

        - Java堆可以物理内存不连续，但逻辑内存连续

        - 大小可以固定也可以扩展（通过-Xmx和-Xms控制），如果在堆中没有内存来完成实例分配，并且无法扩展时会抛出**OutOfMemoryError**异常

    * 方法区（Method Area）

        - **所有线程共享的区域**

        - 用于**存储已被VM加载的类信息、常量、静态变量、即时编译后代码**等数据

        - VM规范将其描述为堆的一个逻辑部分，但它却有一个别名叫Non-Heap（非堆）

        - **垃圾收集行为在这一区域很少出现，回收主要针对常量池的回收和对类型的卸载**

        - 方法区可以物理内存不连续，但逻辑内存连续，大小可以固定也可以扩展

        - 当方法区无法满足内存分配时，会抛出**OutOfMemoryError**异常 

    * 运行时常量池

        - 是方法区的一部分

        - Class文件中除了有**类的版本、字段、方法、接口**等描述信息外，还有一项是**常量池**，用于**存放编译期生成的各种字面量和符号引用**，这部分内容将**在类加载后进入方法区的运行时常量池中存放**。

        - VM规范对Class文件每一部分（包括常量池）的格式都有严格要求，但对运行时常量池没有细节要求，一般来说除了保存Class文件中的描述符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中

        - 运行时常量池相对于Class文件常量池的另一个特征就是具备动态性————运行期间也可以将新的常量放入运行时常池中，比如String的intern（）方法

        - 当常量池无法满足内存分配时，会抛出**OutOfMemoryError**异常 

    * 直接内存

        - 不是VM运行时数据区一部分，也不是VM规范定义的区域

        - NIO类引入了一种基于通道与缓冲区的I/O方式，它可以使用Native函数库直接分配堆外内存（这就是直接内存），然后通过一个存储在Java堆上的DirectByteBuffer对象作为这块内存的引用进行操作，这样能避免在Java堆和Native堆中来回复制数据，提高性能

        - 本机直接内存不受到Java堆大小的限制

        - 当各个内存区域总和大于物理内存限制时会导致动态扩展时出现**OutOfMemoryError**异常

2. HotSpot VM对象探秘

    * 对象的创建

        - 接收到new指令时，检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并检查这个符号引用代表的类是否已被加载、解析和初始化过

        - 

    * 对象的内存布局 

    * 对象的访问定位



